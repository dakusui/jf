= jq-front: JSON with inheritance and templating

`jq-front` is a simple tool to give your JSON files a power of inheritance and templating.

== Background and Introduction

Despite that there are criticisms to use JSON<<json>> as system configuration information's format<<cr>>, JSON still has its beauty such as rich tool supports, good balance between machine's and human's readability and writability, clarity and simplicity in syntax, etc.

However, surely it has some weaknesses when we try to define data structure.
For instance, under a situation, where we need to generate similar but slightly different system configurations repeatedly, it is quite difficult to remove redundant pieces since JSON itself does not define anything about relationships between files or nodes inside files.footnote:[This is not merely a weakness of JSON but also other notations even YAML. YAML has a way to reference another object node from one, still it cannot embed a string value of a text node in another by itself.]

`jq-front` is a tool to cope with such challenges by introducing inheritance and templating into JSON files.

== Installation

=== Ubuntu
Place the file `jq-front` somewhere on your `PATH`.
Followings will be required by `jq-front`

* `jq`
* `bash`
* `npm`
  ** `ajv-cli`

=== With Docker
Add a following entry to your `.bashrc` or a file sourced through it.

[source, bash]
include::jq-front_aliases[]



== Usage

```sh
jq-front [-h|--help] [-e|--enable-templating] [-d|--disable-templating] [--validation=no|strict|lenient] [TARGET]
```

=== Example
Let's prepare files from which you want to create a new JSON by extending.
```sh
$ echo '{"yourname":"Mark"}' > name.json
$ cat name.json
{"yourname":"Mark"}

$ echo '{"greeting":"Hello"}' > greeting.json
$ cat greeting.json
{"greeting":"Hello"}
```

Now, let's try `jq-front`.
```sh
$ echo '{
    "$extends": [
      "greeting.json",
      "name.json"
    ],
    "sayHello": "$(ref .greeting), $(ref .yourname). Toady is $(date). How are you doing?"
  }
  ' | jq-front
  {
    "yourname": "Mark",
    "greeting": "Hello",
    "sayHello": "Hello, Mark. Toady is Fri Aug 30 22:04:40 UTC 2019. How are you doing?"
  }
$
```
Doesn't it seem useful? Have fun!

== Features

With `jq-front`, you can build a JSON object reusing other JSON objects.
To specify JSON objects to be referenced, `jq-front` searches for keys which have special names in a given object.
`$extends` and `$private` are keywords used for this purpose.

Basic features offered by the product are following

* External Inheritance
* Internal Inheritance
* Templating

And usage of them will be discussed in this section.

In this section, we introduce features of the product using following data.

* link:examples/A.json[A.json]
[source, json]
include::examples/A.json[]
* link:examples/AA.json[AA.json]
[source, json]
include::examples/AA.json[]
* link:examples/B.json[B.json]
[source, json]
include::examples/B.json[]
* link:examples/T.json[T.json]
[source, json]
include::examples/T.json[]

=== External Inheritance

In programming languages, inheritance is an indispensable technique to reuse a component.
`jq-front` offers it for the purpose.
A usage example is as follows.

[source, json]
.I.json
----
{
  "$extends": [ "A.json" ],
  "o": "hello world"
}
----

----
jq-front I.json
----

`I.json` will be rendered into the following JSON object with this command line.


[source, json]
.External Inheritance output
----
{
  "a": "A",
  "o": "hello world"
}
----

As you see in the example, the attribute `o` whose value is set to `"A"` in `A.json`, is overridden by the value in `I.json`.

Multiple inheritance is also supported by `jq-front`.
Just by listing file names of JSONs to be inherited, multiple inheritance happens, like `"$extends": ["A.json", "B.json"]`.
When both `A.json` and `B.json` have attributes at the same path, `A.json` side's value will be used.

[source, json]
.J.json
----
{
  "$extends": [ "A.json", "B.json" ]
}
----

That is, `J.json` will be rendered into following output.

[source, json]
.External Multiple Inheritance output
----
{
  "a": "A",
  "b": "B",
  "o": "A"
}
----

As it is so in normal programming language that supports multiple inheritance, avoiding diamond inheritance is a good idea.
Multiple inheritance was implemented to cope with a situation where you want to reuse two JSON objects defined for completely different purposes.
For instance, one is for authentication information and the other is for GUI flavor.

JSON objects that are inherited can also inherit some other JSON files.

[source, json]
.K.json
----
{
  "$extends": [ "AA.json", "B.json" ]
}
----

That is, `K.json` is rendered into a following JSON file.

[source, json]
.External Inheritance output (2)
----
{
  "a": "A",
  "aa": "AA",
  "b": "B",
  "o": "A"
}
----

CAUTION: Ensure that inheritance hierarchy does not have any cyclic dependencies.
Behaviour for this situation is not defined and it will result in stack overflow.


=== Internal Inheritance

"Internal Inheritance" refers to an inheritance happens on an internal (object) node of a given JSON file.
Although it is implemented as a separate mechanism from the external one as it will be discussed in "Design" section, it behaves almost the same as the "external" one.

[source, json]
.L.json
----
{
  "a": {
    "$extends": [ "A.json" ],
    "a": "L"
  }
}
----

[source, json]
.Internal Inheritance output
----
{
  "a": {
    "a": "L",
    "o": "A"
  }
}
----

As it worked for External Inheritance, multiple inheritance works also for Internal Inheritance.

However, for internal nodes, you can also reference "private" nodes not only external files.

[source, json]
.P.json
----
{
  "$private": {
    "nodeA": {
       "aa": "aa"
    },
    "nodeB": {
    }
  },
  "a": {
    "$extends": ["nodeA"],
    "a": "a"
  }
}
----

These nodes can be referenced through "internal inheritance feature" as shown in the example.
Note that you do not need to specify `.json` extension.
And `P.json` will result in following output.

[source, json]
.Private Node Inheritance output
----
{
  "a": {
    "aa": "aa",
    "a": "a"
  }
}
----

=== Templating

Sometimes we need to compose a value of text node from a value of another.
Following is a such an example.

[source, json]
.Version file
----
{
  "releaseVersion": "2.12.0",
  "snapshotVersion": "2.12.0-SNAPSHOT"
}
----

In this example, the version to be released next is `2.12.0`, however the version under the development for it has a suffix `-SNAPSHOT`

To follow the principle of D-R-Y, how should we fix it?
Templating is a feature to offer a solution to this challenge.

We can describe this relationship by using the templating feature of `jq-front`.

[source, json]
.T.json
----
{
  "releaseVersion": "2.12.0",
  "snapshotVersion": "$(ref .releaseVersion)-SNAPSHOT"
}
----

Once you render this file with `jq-front`, you will get the first file (Version file).

`$ref` is a built-in function of `jq-front`, which expands the value of the node specified by the path given as an argument.
Not only built-in functions but also any commands (bash expressions) valid on a platform on which `jq-front` is running can be used here.

For instance, following is a valid input to `jq-front`.
[source, json]
----
{
  "releaseVersion": "2.12.0",
  "snapshotVersion": "$(ref .releaseVersion)-$(date \"+%Y-%m-%d\")"
}
----

And this will result in an output below.
[source, json]
----
{
  "releaseVersion": "2.12.0",
  "snapshotVersion": "2.12.0-2019-08-28"
}
----

This feature can be disabled by `-d` (`--disable-templating`) option.
And to enable it explicitly, you can use `-e` (`--enable-templating`) in case `JF_TEMPLATING_ENABLED` is set to `no`.

==== Built-in `jq-front` functions

===== `ref` function

A function that returns a value of a node specified by an argument.
This function can only work from inside "Work(2)" file.

- parameter:
  * `_path`: path to a node in the file "Work(2)"
- returned value:
  * A value of a node specified by `_path`


===== `self` function

A function that returns a path to a file "Work(2)"
This function can only work from inside "Work(2)" file.

- parameter: (none)
- returned value:
  * A path to "Work(2)" file.


=== Environment variables

You can control behaviours of `jq-front` by setting environment variables described in this section.

==== JF_PATH

From directories listed in `JF_PATH`, `jq-front` searches for requested file.
Entries in the variable is separated by colons(`:`).

When it is searching for a file during internal inheritance resolution, it first searches for private node directory, which is created for temporarily, and if nothing is found, it will then traverses the variable.

===== Default value

`.`

==== JF_TEMPLATING_ENABLED

You can enable `jq-front` 's templating feature by setting this environment variable's value to `yes`.
If any other value is set to the variable, it will not be executed.

===== Default value

`yes`


==== JF_DEBUG

If this variable is set to `enabled`, debug information will be printed to `stderr`.

===== Default value
`disabled`

== Design

Following is a diagram that illustrates `jq-front` 's processing pipeline design.

[ditaa, target="images/pipeline"]
.jq-front's pipeline
----

          external inheritance             private node materialization
                 +----+                             +-----+
   +-------------+ {o}+-=----------+   +------------+ {o} +-=------------+
   |             +----+            |   |            +-----+              | 0...n
   V                               V   V                                 V
+------+                         +-------+                         +------------+
|Source|                         |Work(1)|                         |PrivateNodes|
|{d}   |                         |{d}    |                         |{d}         |
+------+                         +-------+                         +------------+
                                     ^        internal inheritance       ^
                                     |              +-----+              |
                                     +--------------+ {o} +--------------+
                                                    +--+--+
                                                       |
                                                       :
                                                       V
                                                   +---+---+
                                                   |Work(2)|
                                                   |{d}    |
                                                   +---+---+
                                                       ^
                                                       |
                                                       |
                                                    +--+--+
                                                    | {o} | templating(optional)
                                                    +--+--+
+----+       +----+                                    |
|A{o}+-=---->+B{o}| (A writes to B)                    :
+----+       +----+                                    V
                                                   +---+---+
+----+       +----+                                |Output |
|A{o}+------>+B{o}| (A reads from B)               |{d}    |
+----+       +----+                                +---+---+

----

As shown, it consists of four main components, which are "external inheritance", "private node materialization", "internal inheritance", and "templating".

Designs of those components will be described in the rest of this section.

=== External inheritance

'External inheritance' composes a new JSON file from a given one by expanding the files provided through the top-level `$extends` attribute.

At the end of this process, the attribute is removed and copied to the output, "Work(1)" in the diagram.

=== Private node materialization

If the file, "Work(1)" has `$private` attribute whose value is an object node, nodes associated with keys under the attribute are dumped under a temporary directory.
The temporary directory is called 'private node directory'.
The 'private node directory' and its contents are utilized by the "internal inheritance' mechanism.

=== Internal inheritance

Internal inheritance mechanism is a bit more complicated than the external one.

1. Create a base JSON object by the following procedure.
    a. Scan paths of all internal nodes.
    b. For each path, if it ends with `"$extends"`, expand the files specified by the attribute.
    c. Assign the JSON node created in step b. to the parent of the `$extends` attribute.
2. Overlay the JSON object created in the step. 1 with an original JSON object.
3. Remove nodes, i.e., `$extends` and `$private` nodes from the JSON object created in the step 2.

'Private node directory' is inserted before the first entry of `JF_PATH` environment variable when a file to be expanded is searched during the step 1. b.

=== Templating

Templating is executed by performing `eval` on a string below.

----
echo {CONTENT OF Work(2)}
----

And this causes expansions of bash expressions inside the content of "Work(2)" and that expanded string will be printed by the `echo` command.


=== Limitations and Future Work

* Cyclic dependencies are not checked and such a model will result in a stack-overflow.
* Handling of characters that need escaping on templating is naive.

== Authors

* **Hrioshi Ukai** - *Initial work* - https://github.com/dakusui[dakusui]

== link:LICENSE[License]

[source, text]
----
include::LICENSE[]
----

[bibliography]
== References

- [[[cr]]] Thayne McCombs. https://www.lucidchart.com/techblog/2018/07/16/why-json-isnt-a-good-configuration-language/[Why JSON isn’t a Good Configuration Language]: 2018.
- [[[yaml]]] en.wikipedia.org. https://en.wikipedia.org/wiki/YAML[YAML]: 2019
- [[[json]]] json.org. http://www.json.org/[JSON]:2019
