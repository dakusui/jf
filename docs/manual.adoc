== Usage

=== Command Line Interface

[source, bash]
----
jq-front [-h|--help] [-e|--enable-templating] [-d|--disable-templating] [--validation=no|strict|lenient] [TARGET]
----

- `-h`, `--help`: Shows a help
- `-e`, `--enable-templating`: Enables templating (default)
- `-d`, `--disable-templating`: Disables templating
- `--validation`: Validation mode.
`no`, `strict`, and `lenient` are available.
The default is `no`.
- `TARGET`: A file to be processed.

=== Environment variables

You can control behaviours of `jq-front` by setting environment variables described in this section.

==== JF_PATH

From directories listed in `JF_PATH`, `jq-front` searches for requested file.
Entries in the variable are separated by colons(`:`).

When it is searching for a file during node-level inheritance resolution, it first searches for local node directory, which is created for temporarily, and if nothing is found, it will then traverses the variable.

===== Default value

`.`

==== JF_TEMPLATING_ENABLED

You can enable `jq-front` 's templating feature by setting this environment variable's value to `yes`.
If any other value is set to the variable, it will not be executed.

===== Default value

`yes`


==== JF_DEBUG

If this variable is set to `enabled`, debug information will be printed to `stderr`.

===== Default value
`disabled`

== Syntax

=== `$extends` keyword

This keyword can be used as a key whose associated value is an array.
Each element in the array must be a text node.

The string can be one of

* A file in `JF_PATH`.
* When it is placed NOT at the top level of an object node file, a name of a "local node".
* A script invocation directive.

==== File in `JF_PATH` and Local Node

You can specify a file on `JF_PATH` environment variable.
If the name ends with `.yaml` or `.yml`, it will be treated as a YAML file and converted into a JSON file by `yq` command.

As long as your file is under a directory specified by an element in `JF_PATH`, you can use it.
That is, suppose that you have `JF_PATH` and it has a value `.:dir1`.


----
dir1
 |
 `--- child
      |
      `--- J.json
----

The file `J.json` can be referenced by

----
"$extends": ["child/J.json"]
----

In case you have `child/J.json` in multiple places under elements in `JF_PATH`, the first one will be used.
For instance, in the following example, `dir1/child/J.json` will be referenced for the example abobe.

----
dir1
 +--- child
 |    |
 |     `--- J.json
dir2
 |
 `--- child
      |
      `--- J.json
----

You can also specify names of "local nodes". (See the section for `$local` keyword)

==== Script Invocation Directive

You can specify a program which generates a JSON object with a following syntax.

[source, json]
----
{
  "$extends": [
    "SS.sh;bash -eu;dir1/J.json"
  ]
}
----

`SS.sh` is a script file to be executed.
`bash -eu` is a program which executes the script.
`dir1/J.json` is an argument which is passed to the program `SS.sh`.

The string is split by semicolons and the first token is treated as a name of a program to be executed.
The program is searched from `JF_PATH`.
The second toke is a shell with which the program is executed.
And the rest will be passed to the program as arguments.

NOTE: By inserting one or more semicolons, this syntax is triggred.

=== `$local` keyword

This keyword can be used as a key whose associated value is an object.
A value in the object must be an object.

This keyword can only be placed at the top-level of a file.

[source, json]
----
{
  "$local": {
    "A": {
      "a": "valueInA"
    },
    "B": {
      "b": "valueInB"
    },
    "C": {
      "$extends": ["A","B"]
    }
  },
  "D": {
    "$extends": ["C"]
  }
}
----

In this example, local nodes `A`, `B`, and `C` are defined.
And a node at the top level, `D` extends `C`, which then extends `A` and `B`.
This results in a following JSON object.

[source, json]
----
{
  "D": {
    "a": "valueInA",
    "b": "valueInB"
  }
}
----

NOTE: In case you have a local node and a file with the same name, `jq-node` picks up a local node, although you do not need to mind it usually because you do not want to give a suffix `.json` to a local node.

=== `eval:` keyword

This keyword can be used in a text node.
The syntax can be defined as follows.

[source]
----
  eval:[TYPE:]STRING
  TYPE ::= object array string number boolean
----

If `TYPE:` is omitted, in other words `eval:` is followed by anything else than the defined `TYPE`s, `jq-front` behaves as if `string` is specified.

The `STRING` is evaluated by a following command line.

[source, bash]
----
    eval "echo \"${_body}\"" 2>"${_error}"
----

As seen in the above fragment, stderr is redirected to an internal file and the file is checked if a string `ERROR: ` is contained in it.
If the string is found in it, `jq-front` considers that something went wrong during the evaluation and aborts the rest of the process.
Such a string is

Not only variables, functions, and commands visible to a bash shell on which `jq-front` runs, you can use functions provided by the processor.
For more details, refer to <<builtin-functions>> section.

CAUTION: There are similar keywords `template:`, but it is only kept for compatibility and will be removed n the future version of this product.
Please refrain from using it.
In case you want to define a text node that starts with the string itself, you can do ```raw:template:...```


=== `raw:` keyword

You may sometimes want to define a text node which starts with other keywords such as `eval:` itself.
In such cases you can use `raw:` keyword to escape it.

[source]
----
   raw:eval:hello
----

This results in a following output.

[source]
----
   eval:hello
----

[#builtin-functions]
== Built-in `jq-front` functions

In addition to commands and functions visible to a bash shell on which `jq-front` runs, you can use functions listed in this section.

=== `ref` function

A function that returns a value of a node specified by an argument.
This function can only work from inside "Work(2)" file.

- parameter:
* `_path`: path to a node in the file "Work(2)"
- returned value (stdout):
* A value of a node specified by `_path`


=== `self` function

A function that prints the entire file content before templating.

- parameter: (none)
- returned value (stdout):
* Content of the processed file before any templating happens.

=== `cur` function

A function that returns a path to a file "Work(2)"
This function can only work from inside "Work(2)" file.

- parameter: (none)
- returned value (stdout):
* A path to "Work(2)" file.


=== `parent` function

A function that prints a path to a parent node of a given path.

- parameter:
* A path to a node
- returned value (stdout):
* A path to a parent of the node.