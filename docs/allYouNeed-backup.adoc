

[[background]]
== Background

In software industry, although it is considered important practice to follow the "D-R-Y" (Don't repeat yourself) principle<<dry>>, configuration files and other data files sometimes become repetitive.
For example, to configure a distributed system, to define test cases, to define characters and stages for a game, we need to define similar yet slightly different files over and over again.
Some software products avoid this situation by introducing their own syntax to their configuration file specifications.

In this section, we will discuss configuration files of well-known distributed software system managers.
Through this, we will find these application-specific mechanisms can be replaced by a couple of application neutral mechanisms, which are "inheritance" and "interpolation".

**Docker:** For instance, to build an application using `docker`<<docker>> from multiple application images, a user has to write `docker-compose.yaml` file.
Inside the file, a user has to define node values so that they satisfy constraints which the user application and the platform require.

.`docker-compose.yaml` example (generated by ChatGPT 4)
[%collapsible]
====
[source,yaml]
----
version: '3.9'

services:
  webapp1:
    image: mywebapp:latest
    build:
      context: ./webapp
    ports:
      - "8080:80"
    environment:
      - APP_ENV=production
      - APP_DEBUG=false
    volumes:
      - webapp-data:/var/lib/webapp

  webapp2:
    image: mywebapp:latest
    build:
      context: ./webapp
    ports:
      - "8081:80"
    environment:
      - APP_ENV=production
      - APP_DEBUG=false
    volumes:
      - webapp-data:/var/lib/webapp

  db1:
    image: postgres:14
    environment:
      - POSTGRES_USER=user1
      - POSTGRES_PASSWORD=pass1
      - POSTGRES_DB=db1
    ports:
      - "5432:5432"
    volumes:
      - db1-data:/var/lib/postgresql/data

  db2:
    image: postgres:14
    environment:
      - POSTGRES_USER=user2
      - POSTGRES_PASSWORD=pass2
      - POSTGRES_DB=db2
    ports:
      - "5433:5432"
    volumes:
      - db2-data:/var/lib/postgresql/data

volumes:
  webapp-data:
  db1-data:
  db2-data:
----
====

Designers of `docker-compose` are aware of this challenge, and they created application-specific feature for their product called **x-extensions**[<<xExtensionExample>>].
With a method we will see later in the <<technique>> section, it will be shown that this can be addressed without such application-specific mechanisms.

[%collapsible]
====
[[xExtensionExample, example-1]]
[source,yaml]
.**x-extensions example**
----
#file: noinspection YAMLUnusedAnchor
version: '3.9'

x-webapp-service: &webapp-service
  image: mywebapp:latest
  build:
    context: ./webapp
  environment:
    - APP_ENV=production
    - APP_DEBUG=false
  volumes:
    - webapp-data:/var/lib/webapp

x-db-service: &db-service
  image: postgres:14
  ports:
    - "5432:5432"
  environment:
    POSTGRES_PASSWORD: pass123
  volumes:
    - db-data:/var/lib/postgresql/data

services:
  webapp1:
    <<: *webapp-service
    ports:
      - "8080:80"

  webapp2:
    <<: *webapp-service
    ports:
      - "8081:80"

  db1:
    <<: *db-service
    environment:
      - POSTGRES_USER=user1
      - POSTGRES_DB=db1

  db2:
    <<: *db-service
    environment:
      - POSTGRES_USER=user2
      - POSTGRES_DB=db2
    ports:
      - "5433:5432"

volumes:
  webapp-data:
  db-data:
----
====

**Kubernetes and Kustomize:**
**ChatGPT:** Kubernetes<<k8s>> is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications.
It enables developers to manage complex application infrastructure at scale, ensuring high availability and facilitating efficient resource utilization across clusters of hosts.
Kustomize is a Kubernetes-native configuration management tool that allows users to customize and manage Kubernetes resource configurations declaratively.

Following is a folder structure that a user is supposed to define.

[source]
.Kustomize config files (generated by ChatGPT 4)
----
my-app/
├── base/
│   ├── kustomization.yaml
│   ├── deployment.yaml
│   └── service.yaml
└── overlays/
    ├── development/
    │   ├── kustomization.yaml
    │   └── patch-deployment.yaml
    └── production/
        ├── kustomization.yaml
        └── patch-deployment.yaml
----

These files are quite repetitive, and it increases maintenance cost significantly.
There are a couple of schools in the Kubernetes practitioners community about the way to define **Kubernetes** configurations.
One is the **Kustomize** school and the other is **Helm**, which allows using templating in configuration files.
The former places importance more on being declarative and clarity over simplicity in descriptions of configuration files, while the latter does the other way around.

.Contents of Kustomize config files (generated by ChatGPT 4)
[%collapsible]
====
[source,yaml]
.Kustomize: `base/deployment.yaml`:
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:latest
          ports:
            - containerPort: 80
          env:
            - name: DATABASE_URL
              value: jdbc:mysql://localhost:3306/mydatabase----
----

[source,yaml]
.Kustomize: `base/service.yaml`:
----
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
  labels:
    app: my-app
spec:
  type: ClusterIP
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
----

[source,yaml]
.Kustomize: `base/kustomization.yaml`:
----
resources:
  - deployment.yaml
  - service.yaml
----

[source,yaml]
.`overlays/development/deployment.yaml`
----
resources:
  - ../../base

patchesStrategicMerge:
  - patch-deployment.yaml
----

[source,yaml]
.Kustomize: `overlays/development/patch-deployment.yaml`:
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 2
  template:
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:dev-latest
          env:
            - name: DATABASE_URL
              value: jdbc:mysql://dev-db:3306/mydatabase
  selector:
    matchLabels:
      app: my-app
----

[source,yaml]
.`overlays/production/deployment.yaml`
----
resources:
  - ../../base

patchesStrategicMerge:
  - patch-deployment.yaml
----

[source,yaml]
.`overlays/production/patch-deployment.yaml`
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 5
  template:
    spec:
      containers:
        - name: my-app-container
          image: my-app-image:prod-latest
          env:
            - name: DATABASE_URL
              value: jdbc:mysql://prod-db:3306/mydatabase
  selector:
    matchLabels:
      app: my-app
----
====

**Terraform:**

So far, we have discussed only containerization platforms and their application configurations.
However, the same thing keeps happening in the software industry.

For instance, in the gaming industry,

In

<<jq-front>>

Challenges:

- Inheritances,
- References,
- Interpolation,

Pains

- Similar, yet different notations and implementations
- Expensive learning cost needs to be paid whenever diving in a new application

Status Quo Solutions

- Custom Application-specific solutions

Proposed Solution

- Separation of Concerns, Pipelining
- JSON++, which supports Inheritance, References, Interpolation
- Most notations are defined as supersets of JSON.
- Most
