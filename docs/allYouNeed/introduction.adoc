:toc:

[[introduction]]
== Introduction

**Status Quo:** Not a few similar yet different notations have been proposed and applied to various software products to describe information with complex structures and constraints.

This is a situation found especially frequent in configuration files of distributed systems backed by containerized virtualization solutions, but not limited to.
In distributed system management, there are tools to manage instances under **docker**<<docker>> and **Kubernetes**<<k8s>>.
Most of them use **YAML**<<kustomize>><<helm>><<docker-compose>>, but **Terraform**<<terraform>> uses its own notation; **HCL**.
Not only that, in testing field, **runn**<<runn>> and **commandunit**<<commandunit>> use **YAML**<<yaml>>, while **Cucumber**<<cucumber>> uses **Gherkin**<<gherkin>>.
Another notation is **TOML**, which is used for building python projects<<pyproject>>, widely used for python projects, but not limited to.
For instance, configuring blog system<<hugo>>.

In short, currently, various applications use various notations to define their own DSLs for system configurations, tests, or product management.
However, they share common concerns and keep addressing similar problems repetitively, which is inefficient, error-prone, and raising learning costs for users.
This is a situation violating principle in the UNIX philosophy: "Make each program do one thing well" and "Don't repeat yourself".

**Proposed Method:**  We propose a new method, which is designed based on the following ideas:

1. Consider human readability and conciseness are completely separate concerns.
"Conciseness" here means the ability to describe structured information without redundancy under a given grammarfootnote:humanReadability[Verboseness of the grammar should be addressed as a part of human-readability and achieved by the design of the grammar.].
2. Introduce notation neutral syntax to express data concisely.
The syntax is designed to be surjective from one notation to itself.
It has a few keywords to enable inheritances and computations of node values from others.
Given a notation *N*, a new notation enhanced by the syntax will be called **N{plus}{plus}**
In general, each well-known notation can be converted into/back from **JSON**<<json>>.
This means once we implement **N{plus}{plus}** processor for **JSON**, it can be used for all these notations mentioned above just by employing it as a stage in a pipeline.
We call **N{plus}{plus}** for **JSON** as "**JSON{plus}{plus}**", and documents written in it **JSON{plus}{plus}** documents in this article.
Its processor renders a **JSON{plus}{plus}** document into a conventional **JSON** document.
3. We also present a reference implementation of a processor for **JSON{plus}{plus}**, called **jq-front**<<jq-front>>.

In this article, we provide a working example of toolchains, where notations are focusing on human-readability, applications are focusing on its functionalities, and "machine-readability" is taken care of by an independent component.
With this, we aim at delivering a way to achieve "Build programs to work together", another important UNIX philosophy.

**Evaluation and Results:** In the <<results>> section, we will show case-study results, where the method is applied to a few real-world examples, such as **TOML**<<toml>> used in `pyproject.toml`, tests written in **Gherkin** and **YAML**,

It will also be discussed how and when proposed approach becomes beneficial comparing to another approach, where "templating engines" are employed in the <<discussion>> section.

**Contributions:** This paper makes the following contributions:

- A Novel Architecture: t.b.d.
- Empirical Validation: t.b.d. style example: We demonstrate the effectiveness of our model on machine translation tasks, achieving state-of-the-art performance on the WMT 2014 English-to-German dataset.
- Generalizability: t.b.d. style example: We show that the Transformer architecture generalizes well to other sequence modeling tasks, including text summarization and question answering.


The rest of this paper is organized as follows:
In <<background>>, we will discuss how the problem of repetitiveness in configuration files and other sorts of files has been addressed, or not addressed.
In <<technique>>, the details of our approach and the syntax we designed for this approach will be described.
Then in <<results>>, we look into how much the approach can reduce the size of configuration files by applying it to an actual example.
In the <<conclusion>>, we will summarize our findings and future works.
