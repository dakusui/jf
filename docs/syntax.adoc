== Syntax

=== `$extends` keyword

This keyword can be used as a key whose associated value is an array.
Each element in the array must be a text node.

The string can be one of

* A file in `JF_PATH`.
* When it is placed NOT at the top level of an object node file, a name of a "local node".
* A script invocation directive.

==== File in `JF_PATH` and Local Node

You can specify a file on `JF_PATH` environment variable.
If the name ends with `.yaml` or `.yml`, it will be treated as a YAML file and converted into a JSON file by `yq` command.

As long as your file is under a directory specified by an element in `JF_PATH`, you can use it.
That is, suppose that you have `JF_PATH` and it has a value `.:dir1`.

----
dir1
 |
 `--- child
      |
      `--- J.json
----

The file `J.json` can be referenced by

----
"$extends": ["child/J.json"]
----

In case you have `child/J.json` in multiple places under elements in `JF_PATH`, the first one will be used.
For instance, in the following example, `dir1/child/J.json` will be referenced for the example abobe.

----
dir1
 +--- child
 |    |
 |     `--- J.json
dir2
 |
 `--- child
      |
      `--- J.json
----

You can also specify names of "local nodes".
(See the section for `$local` keyword)

==== Script Invocation Directive

You can specify a program which generates a JSON object with a following syntax.

[source,json]
----
{
  "$extends": [
    "SS.sh;bash -eu;dir1/J.json"
  ]
}
----

`SS.sh` is a script file to be executed.
`bash -eu` is a program which executes the script.
`dir1/J.json` is an argument which is passed to the program `SS.sh`.

The string is split by semicolons and the first token is treated as a name of a program to be executed.
The program is searched from `JF_PATH`.
The second toke is a shell with which the program is executed.
And the rest will be passed to the program as arguments.

NOTE: By inserting one or more semicolons, this syntax is triggred.

=== `$local` keyword

This keyword can be used as a key whose associated value is an object.
A value in the object must be an object.

This keyword can only be placed at the top-level of a file.

[source,json]
----
{
  "$local": {
    "A": {
      "a": "valueInA"
    },
    "B": {
      "b": "valueInB"
    },
    "C": {
      "$extends": ["A","B"]
    }
  },
  "D": {
    "$extends": ["C"]
  }
}
----

In this example, local nodes `A`, `B`, and `C` are defined.
And a node at the top level, `D` extends `C`, which then extends `A` and `B`.
This results in a following JSON object.

[source,json]
----
{
  "D": {
    "a": "valueInA",
    "b": "valueInB"
  }
}
----

NOTE: In case you have a local node and a file with the same name, `jq-node` picks up a local node, although you do not need to mind it usually because you do not want to give a suffix `.json` to a local node.

=== `eval:` keyword

This keyword can be used in a text node.
The syntax can be defined as follows.

[source]
----
  eval:[TYPE:]STRING
  TYPE ::= object array string number boolean
----

If `TYPE:` is omitted, in other words `eval:` is followed by anything else than the defined `TYPE`s, `jq-front` behaves as if `string` is specified.

The `STRING` is evaluated by a following command line.

[source,bash]
----
    eval "echo \"${_body}\"" 2>"${_error}"
----

As seen in the above fragment, stderr is redirected to an internal file and the file is checked if a string `ERROR: ` is contained in it.
If the string is found in it, `jq-front` considers that something went wrong during the evaluation and aborts the rest of the process.
Such a string is

Not only variables, functions, and commands visible to a bash shell on which `jq-front` runs, you can use functions provided by the processor.
For more details, refer to <<builtin-functions>> section.

CAUTION: There are similar keywords `template:`, but it is only kept for compatibility and will be removed n the future version of this product.
Please refrain from using it.
In case you want to define a text node that starts with the string itself, you can do ```raw:template:...```

=== `raw:` keyword

You may sometimes want to define a text node which starts with other keywords such as `eval:` itself.
In such cases you can use `raw:` keyword to escape it.

[source]
----
   raw:eval:hello
----

This results in a following output.

[source]
----
   eval:hello
----

[#builtin-functions]
== Built-in `jq-front` functions

In addition to commands and functions visible to a bash shell on which `jq-front` runs, you can use functions listed in this section.

=== `ref` function

A function that returns a value of a node specified by an argument.
This function can only work from inside "Work(2)" file.

- parameter:
* `_path`: path to a node in the file "Work(2)"
- returned value (stdout):
* A value of a node specified by `_path`

==== Example

(t.b.d.)

===== Input

(t.b.d.)

===== Result

(t.b.d.)

=== `self` function

A function that prints the entire file content before templating.

- parameter: (none)
- returned value (stdout):
* Content of the processed file before any templating happens.

==== Example

(t.b.d.)

===== Input

(t.b.d.)

===== Result

(t.b.d.)

=== `cur` function

A function that returns a path to a node a current node.

- parameter: (none)
- returned value (stdout):
* A path to "Work(2)" file.

==== Examples

[cols="1a,1a"]
|===
|Input |Output

|
[source,json]
.A.json
----
{
  "a": {
    "b": {
       "c": "eval:$(cur)"
    }
  }
}
----
|[source,json]
----
{
  "a": {
    "b": {
       "c": ".a.b.c"
    }
  }
}
----

|
[source,json]
.X.JSON
----
{
  "x": {
    "$extends": ["A.json"]
  }
}
----
|[source,json]
----
{
  "x": {
    "a": {
      "b": {
         "c": ".x.a.b.c"
      }
    }
  }
}
----

|===

NOTE: Notice that jq-front first expands all the inheritances in the input and then invokes the 'templating' mechanism.
Thus, `cur` function calls in inherited files are evaluated based on paths where they appear in the expanded file.

=== `parent` function

A function that prints a path to a parent node of a given path.

- parameter:
* A path to a node
- returned value (stdout):
* A path to a parent of the node.

==== Examples

[cols="1a,1a"]
|===
|Input |Output

|
[source,json]
----
"eval:$(parent .hello.world)"
----

|[source,json]
----
".hello"
----

|===
