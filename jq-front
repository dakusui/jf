#!/usr/bin/env bash
set -E -o nounset -o errexit +o posix -o pipefail
shopt -s inherit_errexit

JF_BASEDIR=$(dirname "$(readlink --canonicalize "${0}")")
export JF_BASEDIR

# shellcheck disable=SC1090
# source = lib/shared.sh
source "${JF_BASEDIR}/lib/shared.sh"
# shellcheck disable=SC1090
# source = lib/nodepool.sh
source "${JF_BASEDIR}/lib/nodepool.sh"

function _debug_abort() {
  print_stacktrace "DEBUG: error trapped"
  exit 1
}

function _mangle_path() {
  local _path="${1}"
  local _path_base="${2}"
  local _ret=""
  if [[ -z "${_path_base}" ]]; then
    echo "${_path}"
    return 0
  fi
  IFS=":" read -r -a _arr <<<"${_path}"
  for i in "${_arr[@]}"; do
    local _cur="${_path_base}"
    if [[ ${i} == .* ]]; then
      # _JF_CWD always starts with '/' since it is an absolute path to current working directory by definition.
      _cur="${_cur}${i/./${_JF_CWD}}"
    else
      _cur="${_cur}${i}"
    fi
    if [[ "${_ret}" == "" ]]; then
      _ret="${_cur}"
    else
      _ret="${_ret}:${_cur}"
    fi
  done
  echo "${_path_base}:${_ret}"
}

function _remove_meta_nodes() {
  local _content="${1}"
  local _cur
  if is_object "${_content}"; then
    local _keys i
    _cur="$(mktemp_with_content "${_content}")"
    # Intentional single quote to find a keyword that starts with '$'
    # shellcheck disable=SC2016
    mapfile -t _keys < <(_paths_of_extends "${_content}") || _keys=()
    for i in "${_keys[@]}"; do
      local _next
      _next="$(mktemp_with_content "$(jq ".|del(${i})" "${_cur}")")"
      _cur="${_next}"
    done
    cat "${_cur}"
  else
    echo "${_content}"
  fi
}

# Latter overrides former
function _merge_object_nodes() {
  local _a="${1}"
  local _b="${2}"
  local _error
  _error=$(mktemp)
  perf "begin"
  debug "merging _a:'${_a}' and _b:'${_b}'"
  [[ "${_a}" != '' ]] || abort "An empty string was given as _a"
  # shellcheck disable=SC2016
  jq -r -c -n --argjson a "${_a}" --argjson b "${_b}" -L "${JF_BASEDIR}/lib" \
    'import "shared" as shared;
    def value_at($n; $p):
      $n | getpath($p);

    def setvalue_at($n; $p; $v):
      def type_of($v):
        $v | type;
      def _setvalue_at($n; $p; $v):
        $n | try setpath($p; $v)
             catch error("Failed to process node at path:<\($p|shared::path2pexp(.[]))>; the value:<\($v)>).");
      $n | if type_of($v)=="object" or type_of($v)=="array" then
             if type_of(value_at($n; $p))!="object" and type_of(value_at($n; $p)!="array") then
               _setvalue_at(.;$p; $v)
             else
               .
             end
           else
             _setvalue_at(.; $p; $v)
           end;

    def merge_objects($a; $b):
      $b | [paths(scalars_or_empty)]
         | reduce .[] as $p ($a; setvalue_at(.; $p; value_at($b; $p)));

    merge_objects($a; $b)' 2>"${_error}" || {
    abort "$(printf "jq-front: Failed to merge object nodes:\n    a=<%s>\n    b=<%s>\nERROR: %s)" \
      "$(jq -r -c -n "${_a}|." || echo "MALFORMED: ${_a}")" \
      "$(jq -r -c -n "${_b}|." || echo "MALFORMED: ${_b}")" \
      "$(cat "${_error}" || echo "UNAVAILABLE")")"
  }
  perf "end"
}

function _expand_nodelevel_inheritances() {
  local _content="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _cur _in i
  local -a _keys
  perf "begin"
  debug "target='${_content}'"
  _cur=$(mktemp_with_content '{}')
  # Intentional single quote to find a keyword that starts with '$'
  # shellcheck disable=SC2016
  mapfile -t _keys < <(_paths_of_extends "${_content}") || _keys=()
  [[ $? == 0 ]] || abort "Node-level expansion was failed for node:'${_content}'"
  for i in "${_keys[@]}"; do
    local j
    local -a _extendeds
    local _p="${i%.\"\$extends\"}"
    mapfile -t _extendeds < <(echo "${_content}" | jq -r -c "${i}[]") || _extendeds=()
    for j in "${_extendeds[@]}"; do
      local _jj _cur_content _tmp_content _original_filename
      _original_filename="$(search_file_in "${j}" "${_path}")"
      _jj="$(validate_file_in_path "${_original_filename}" "${_validation_mode}" "${_path}")" ||
        abort "Failed to locate file '${j}'"
      _check_cyclic_dependency "${_original_filename}" inheritance
      debug "check - 1"
      local _next_content
      _next_content="$(cat "${_jj}")"
      debug "check - 2"
      is_json "${_next_content}" || abort "Malformed JSON was given:'${_jj}'='${_next_content}'"
      _cur_content="$(cat "${_cur}")"
      debug "check - 3"
      local _merged_piece_content
      if has_value_at "${_p}" "${_cur_content}"; then
        local _cur_piece _next_piece
        debug "check - 4a"
        _cur_piece="$(echo "${_cur_content}" | jq "${_p}")"
        _next_piece="$(expand_inheritances "${_jj}" "${_validation_mode}" "${_path}")"
        _merged_piece_content="$(_merge_object_nodes "${_cur_piece}" "${_next_piece}")"
        [[ $? == 0 ]] || abort "Failed to merge file:'${_cur}' with file:'${_jj}'"
        debug "check - 4b"
      else
        local _expanded_tmp
        debug "check - 5a: '${_jj}'"
        _expanded_tmp="$(expand_inheritances "${_jj}" "${_validation_mode}" "${_path}")"
        [[ $? == 0 ]] || abort "Failed to expand inheritances for '${_jj}'"
        debug "check - 5b"
        _merged_piece_content="${_expanded_tmp}"
        debug "check - 5c"
      fi
      debug "check - 6"
      _tmp_content="$(jq -n "input | ${_p}=input" "${_cur}" <(echo "${_merged_piece_content}"))"
      _cur=$(mktemp_with_content "${_tmp_content}") || abort "TODO(2)"
      _unmark_as_in_progress "${_original_filename}" inheritance
      debug "check - 7"
    done
  done
  perf "end"
  jq -r -c . "${_cur}"
}

function validate_file_in_path() {
  local _in="${1}"
  local _mode="${2}"
  local _path="${3}"
  debug "${FUNCNAME[0]}: validating ${_in}"
  validate_jf_json "${_in}" "${_validation_mode}"
  debug "${FUNCNAME[0]}: ...validated"
  echo "${_in}"
}

function _source_files() {
  local _i _files
  # We know that there is no alphanumerically named files under $(_source_files_dir)
  # shellcheck disable=SC2012
  mapfile -t _files <<<"$(ls "$(_sourced_files_dir)" | sort -n)"
  for _i in "${_files[@]}"; do
    [[ "${_i}" == "" ]] && break
    # shellcheck disable=SC1090
    source "$(_sourced_files_dir)/${_i}"
  done
}

function _define_builtin_functions() {
  ####
  #
  # This is a function intended to be used on templating (_render_text_node)
  function ref() {
    # shellcheck disable=SC2181
    [[ $? == 0 ]] || abort "${_error_prefix}Failure was detected."
    local _path="${1}"
    local value type
    value=$(value_at "${_path}" "$(cat "$(self)")")
    type="$(type_of "${value}")"
    debug "value:'${value}'(type:'${type}')"
    if [[ "${type}" == string && ("${value}" == eval:* || "${value}" == template:*) ]]; then
      local ret
      _check_cyclic_dependency "${_path}" reference
      ret="$(_render_text_node "${value}" "${_path}" "${_self}")"
      _unmark_as_in_progress "${_path}" reference
      jq -r -c '.' <(echo "${ret}")
    else
      echo "${value}"
    fi
  }

  ####
  # Prints the entire file (before templating).
  #
  # This is a function intended to be used on templating (_render_text_node)
  function self() {
    # shellcheck disable=SC2181
    [[ $? == 0 ]] || abort "${_error_prefix}Failure was detected."
    echo "${_self}"
  }
  ####
  # A function that prints a node path to the text node, where the calls this function is directly made.
  function curn() {
    # shellcheck disable=SC2181
    [[ $? == 0 ]] || abort "${_error_prefix}Failure was detected."
    debug "cur:_path='${_path}'"
    echo "${_path}"
  }

  ####
  # A function that prints a node path to a container element, which is an array or an object, that encloses the entry
  # belongs to.
  # An entry here means a pair of key and value or an element in an array.
  function cur() {
    parent "$(curn)"
  }

  ####
  # Prints a path to a parent node of a given path.
  # Note that single level path results in an empty string.
  # That is ```parent .node``` will print nothing.
  # This is intentional to be able to do ```$(ref $(parent $(cur)).uncle)``` even if ```$(cur)``` is either
  # ```.node``` or ```.node.child```
  function parent() {
    # shellcheck disable=SC2181
    [[ $? == 0 ]] || abort "${_error_prefix}Failure was detected."
    local _path="${1}"
    local _level="${2:-1}"
    if [[ ! "${_path}" == .* ]]; then
      abort "Path was not valid:(${_path}), it must start with a '.'"
    fi
    if [[ "${_path}" == "." ]]; then
      abort "Root does not have a parent.:(${_path})"
    fi
    jq -r -c -n -L "${JF_BASEDIR}/lib" \
      'import "shared" as shared;
      .|path('"${_path}"')|.[0:-'"${_level}"']|shared::path2pexp(.)'
  }

  function error() {
    abort "${@}"
  }
}

function _render_text_node() {
  local _node_value="${1}"
  local _path="${2}" # DO NOT REMOVE: This local variable is referenced by built-in functions invoked on 'templating' stage.
  local _self="${3}" # DO NOT REMOVE: This local variable is referenced by built-in functions invoked on 'templating' stage.
  local _mode="raw" _quote="yes" _ret_code=0
  local _body _ret
  if [[ "${_node_value}" != template:* && "${_node_value}" != eval:* && "${_node_value}" != raw:* ]]; then
    abort "Non-templating text node"
  fi
  _mode="${_node_value%%:*}"
  _body="${_node_value#*:}"
  if [[ "${_body}" == object:* || "${_body}" == array:* || "${_body}" == string:* || "${_body}" == number:* || "${_body}" == boolean:* ]] \
    ; then
    if [[ "${_body}" != string:* ]]; then
      _quote="no"
    fi
    _body="${_body#*:}"
  fi

  if [[ "${_mode}" == "template" || "${_mode}" == "eval" ]]; then
    local _error_prefix="ERROR: "
    local _error _error_out
    export _path
    _error="$(mktemp)"
    # Perform the 'templating'
    _ret="$(eval "echo \"${_body}\"" 2>"${_error}")"
    unset _path
    # shellcheck disable=SC2002
    _error_out="$(cat "${_error}")"
    [[ "${_error_out}" != *"${_error_prefix}"* ]] || abort "Error was detected during templating: $(cat "${_error}")"
    debug "stderr during eval:'${_error_out}'"
  elif [[ "${_mode}" == "raw" ]]; then
    _ret="${_body}"
  fi
  if [[ "${_quote}" == yes ]]; then
    _ret="${_ret//\\/\\\\}"
    echo "\"${_ret//\"/\\\"}\""
  else
    echo "${_ret}"
  fi
  return "${_ret_code}"
}

function _paths_of_string_type() {
  local _content="${1}"
  echo "${_content}" | jq -r -c -L "${JF_BASEDIR}/lib" '#---
import "shared" as shared;

[paths(scalars_or_empty
      |select(type=="string" and (startswith("eval:") or
                                  startswith("template:"))))]
              |sort
              |sort_by(length)
              |.[]
              |shared::path2pexp(.)'
}

function _paths_of_extends() {
  local _content="${1}"
  echo "${_content}" | jq -r -c -L "${JF_BASEDIR}/lib" '#---
import "shared" as shared;

[paths(..)|. as $p|.[-1]|select(tostring=="$extends")|$p]
              |sort
              |sort_by(length)
              |.[]
              |shared::path2pexp(.)'
}

function _perform_templating() {
  local _content="${1}"
  local _ret="${_content}"
  local i
  local -a _keys
  # Shorter path comes earlier than longer.
  mapfile -t _keys < <(_paths_of_string_type "${_content}")
  for i in "${_keys[@]}"; do
    local _node_value _templated_node_value _ret_file
    _node_value="$(value_at "${i}" "${_ret}")"
    _ret_file=$(mktemp_with_content "${_ret}")
    _templated_node_value="$(_render_text_node "${_node_value}" "${i}" "${_ret_file}")"
    _ret="$(jq -r -c -n "input|${i}=input" <(echo "${_ret}") <(echo "${_templated_node_value}"))"
  done
  echo "${_ret}"
}

function _starts_with_templating_keyword() {
  local _node_value="${1}"
  if [[ "${_node_value}" == template:* || "${_node_value}" == eval:* || "${_node_value}" == raw:* ]]; then
    return 0
  fi
  return 1
}

function find_file_in_path() {
  local _target="${1}"
  local _path="${2}"
  IFS=';' read -r -a _arr <<<"${_target}"
  if [[ ${#_arr[@]} -le 1 ]]; then
    local _file
    _file="$(search_file_in "${_target}" "${_path}")"
    if [[ "${_target}" == *.yaml || "${_target}" == *.yml ]]; then
      local _content
      _content="$(yq . "${_file}")"
      mktemp_with_content "${_content}"
    else
      debug "${FUNCNAME[0]}: '${_file}'"
      echo "${_file}"
    fi
  elif [[ ${#_arr[@]} -gt 1 ]]; then
    local _f
    _f="$(search_file_in "${_arr[0]}" "${_path}")" || abort "Script file ${_arr[1]} was not found in '${_path}'"
    if [[ ${_arr[1]} == SOURCE ]]; then
      # shellcheck disable=SC1090
      #  We know that there are no non-alphanumerically named files.
      # shellcheck disable=SC2012
      cat "${_f}" >"$(_sourced_files_dir)/$(ls "$(_sourced_files_dir)" | wc -l)"
      mktemp_with_content "{}"
    else
      ####
      # In case the file name contains one or more semi-colons(';'), the name will be splitted by it.
      # And a command line is constructed from them and executed.
      export _path
      mktemp_with_content "$(${_arr[1]} "${_f}" "${_arr[@]:2}")"
      unset _path
    fi
  fi
}

####
#
# Function intended to be used on 'script inheritance'.
# Search for a file from an environment variable "_JF_PATH" and prints an absolute path of it if found.
# In case it is not found, 1 will be returned.
#
# This function is indirectly called by 'find_file_in_path' through a command line it constructs
#
function find_file() {
  local _target="${1}"
  search_file_in "${_target}" "${_path}"
}

function export_names_for_script_inheritance() {
  export -f find_file
  export -f search_file_in
  export -f abort
  export -f message
  export _JF_PATH
  export _JF_PATH_BASE
}

function validate_jf_json() {
  local _in="${1}"
  local _mode="${2}"
  if [[ "${_mode}" == "no" ]]; then
    return 0
  elif [[ "${_mode}" == "strict" ]]; then
    _validate_jf_json_with "${_in}" "strict"
  elif [[ "${_mode}" == "lenient" ]]; then
    _validate_jf_json_with "${_in}" "lenient"
  else
    abort "Unknown validation mode:'${_mode}' was set."
  fi
  return $?
}

function dirof() {
  local _target="${1}"
  local _ret
  _ret=$(dirname "$(readlink --canonicalize-missing "${_target}")")
  echo "${_ret}"
}

function _encode_filename() {
  local _filename="${1}"
  local _dependency_space="${2}"
  local _ret
  _ret="${_JF_SESSION_DIR}/${_dependency_space}-$(hashcode "${_filename}").txt"
  echo "${_ret}"
}

function _mark_as_in_progress() {
  local _filename="${1}"
  local _dependency_space="${2}"
  local _encoded_filename
  _encoded_filename="$(_encode_filename "${_filename}" "${_dependency_space}")"
  touch "${_encoded_filename}"
}

function _unmark_as_in_progress() {
  local _filename="${1}"
  local _dependency_space="${2}"
  local _encoded_filename
  _encoded_filename="$(_encode_filename "${_filename}" "${_dependency_space}")"
  rm "${_encoded_filename}" || {
    message "WARN: ${_filename} was not found."
  }
}

function _is_in_progress() {
  local _filename="${1}"
  local _dependency_space="${2}"
  local _encoded_filename
  _encoded_filename="$(_encode_filename "${_filename}" "${_dependency_space}")"
  if [[ -e "${_encoded_filename}" ]]; then
    debug "'${_filename}'(${_encoded_filename}) is in progress"
    return 0
  fi
  debug "'${_filename}'(${_encoded_filename}) is NOT in progress"
  return 1
}

function _check_cyclic_dependency() {
  local _in="${1}"
  local _dependency_space="${2}"
  if _is_in_progress "${_in}" inheritance; then
    abort "Cyclic ${_dependency_space} was detected on:'${_in}'"
  else
    _mark_as_in_progress "${_in}" inheritance
  fi
}

function expand_filelevel_inheritances() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  ####
  # This is intentionally using single quotes to pass quoted path expression to jq.
  # shellcheck disable=SC2016
  local _in _cur _content _original_filename
  perf "begin"
  _original_filename="$(search_file_in "${_target}" "${_path}")"
  _in="$(find_file_in_path "${_target}" "${_path}")"
  debug "check - 1"
  debug "validating ${_in}"
  validate_jf_json "${_in}" "${_validation_mode}"
  debug "...validated"
  debug "check - 2"
  _check_cyclic_dependency "${_original_filename}" inheritance
  debug "check - 3"
  _content="$(cat "${_in}")"
  _cur="${_content}"
  if is_object "${_content}"; then
    # shellcheck disable=SC2016
    # this is intentionally suppressing expansion to pass the value to jq.
    debug "check - 4.a"
    if has_value_at '."$extends"' "${_content}"; then
      local i
      while IFS= read -r i; do
        local _next _c _parent
        _parent="$(expand_inheritances "${i}" "${_validation_mode}" "${_path}")"
        _c="$(_merge_object_nodes "${_parent}" "${_cur}")"
        # Cannot check the exit code directly because of command substitution
        # shellcheck disable=SC2181
        [[ $? == 0 ]] || abort "Failed to merge file:'${i}' with content:'${_cur}'"
        _cur="${_c}"
      done <<<"$(value_at '."$extends"[]' "${_content}")"
    fi
    local _cur_tmpfile
    debug "check - 4.b"
    _cur_tmpfile="$(mktemp_with_content "${_cur}")"
    jq -r -c '.|del(.["$extends"])' "${_cur_tmpfile}"
    debug "check - 4.c"
  else
    debug "check - 5.a"
    cat "$(find_file_in_path "${_cur}" "${_path}")"
    debug "check - 5.b"
  fi
  debug "check - 6"
  _unmark_as_in_progress "${_original_filename}" inheritance
  debug "check - 7"
  perf "end"
}

function materialize_private_nodes() {
  local _target="${1}"
  local _content _ret
  debug "begin:materialize_private_nodes"
  _content="$(cat "${_target}")"
  _ret="$(mktemp -d)"
  # Intentional single quotes for jq.
  # shellcheck disable=SC2016
  if has_value_at '."$local"' "${_content}"; then
    # shellcheck disable=SC2016
    for i in $(keys_of '."$local"' "${_content}"); do
      echo "${_content}" | jq '."$local".''"'"${i}"'"' >"${_ret}/${i}"
    done
  fi
  echo "${_ret}"
  debug "end:materialize_private_nodes"
}

function expand_nodelevel_inheritances() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _expanded _expanded_clean _clean _content _ret
  perf "begin:_target=${_target}"
  _content="$(cat "${_target}")"
  _expanded="$(_expand_nodelevel_inheritances "${_content}" "${_validation_mode}" "${_path}")" ||
    abort "Failed to expand node level inheritance for file:'${_target}'(1)"
  _clean="$(_remove_meta_nodes "${_content}")"
  _expanded_clean="$(_remove_meta_nodes "${_expanded}")"
  _ret=$(_merge_object_nodes "${_expanded_clean}" "${_clean}") || abort "Failed to expand node level inheritance for file:'${_target}'(content:'${_content}')(2)"
  echo "${_ret}"
  perf "end"
}

function expand_inheritances_of_private_nodes() {
  local _path="${1}"
  local _templating="${2}"
  local _jf_path="${3}"
  debug "begin: expand_inheritances_of_private_nodes in ${_path}"
  while IFS= read -r -d '' i; do
    local _tmp
    local _f="${i}"
    debug "expanding inheritance of private node:${i}"
    _tmp="$(mktemp_with_content "$(expand_inheritances "${_f}" "no" "${_path}:${_jf_path}")")"
    cp "${_tmp}" "${_f}"
    debug "...expanded"
  done < <(find "${_path}" -maxdepth 1 -type f -print0)
  debug "end:   expand_inheritances_of_private_nodes"
}

function _nodepool_expand_inheritances() {
  local _nodeentry="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _content _out _absfile _processor _args _ret
  local -a _specifier

  mapfile -t -d ';' _specifier <<<"${_nodeentry};;"
  _absfile="$(_locate_file "${_specifier[0]}" "${_path}")"
  _processor="${_specifier[1]}"
  _args="${_specifier[2]}"

  perf "begin: ${_nodeentry}"
  _absfile="$(find_file_in_path "${_absfile}" "${_path}")"
  # Fail on command substitution cannot be checked directly
  # shellcheck disable=SC2181
  [[ $? == 0 ]] || abort "Failed to find a file '${_absfile}'."
  # Update _path to be able to find a file placed in the same directory as _absfile's
  _path="$(dirof "${_absfile}"):${_path}"
  _content="$(cat "${_absfile}")"
  _content="$(jsonize "${_absfile}" "${_processor}" "${_args}")"
  if ! is_json "${_content}"; then
    abort "Malformed JSON was given:'${_nodeentry}'='${_content}'"
  fi
  if is_object "${_content}"; then
    local _tmp _private_nodes_dir _c _expanded
    ####
    # Strangely the line below does not causes a quit on a failure.
    # Explitly check and abotrt this functino.
    _c="$(expand_filelevel_inheritances "${_absfile}" "${_validation_mode}" "${_path}")" ||
      abort "File-level expansion failed for '${_absfile}'"
    _tmp="$(mktemp_with_content "${_c}")"
    _private_nodes_dir=$(materialize_private_nodes "${_tmp}")
    expand_inheritances_of_private_nodes "${_private_nodes_dir}" \
      "enabled" \
      "${_private_nodes_dir}:${_path}"
    _expanded="$(expand_nodelevel_inheritances "${_tmp}" "${_validation_mode}" "${_private_nodes_dir}:${_path}")" ||
      abort "Failed to expand node level inheritance for file:'${_nodeentry}'(3)"
    _out=$(mktemp_with_content "${_expanded}")
  else
    : # Clear $?
    _out="$(mktemp_with_content "${_content}")"
  fi
  cat "${_out}"
  perf "end: ${_nodeentry}"
  #----------------------
}

function _jsonize_file() {
  local _absfile="${1}" _processor="${2:-""}" _args="${3:-""}"
  local _ret
  if [[ ${_processor} == "" ]]; then
    local _cmd="jq"
    if [[ "${_absfile}" == *.yaml || "${_absfile}" == *.yml ]]; then
      _cmd="yq"
    fi
    # Let the args split. Since it's args.
    # shellcheck disable=SC2086
    _ret="$(${_cmd} . ${_args} "${_absfile}")"
  else
    if [[ "${_processor}" == SOURCE ]]; then
      # Only number of files matters and it's safe to use ls here.
      # shellcheck disable=SC2012
      cp "${_absfile}" "$(_sourced_files_dir)/$(ls "$(_sourced_files_dir)" | wc -l)"
      _ret="{}"
    else
      export _path
      _ret="$("${_processor}" "${_absfile}" ${_args} | jq .)"
      unset _path
    fi
  fi
  echo "${_ret}"
}

function _sourced_files_dir() {
  echo "${_JF_SESSION_DIR}/source_files"
}

function _validate_jf_json_with() {
  _validate_json "${1}" "${_JF_SCHEMA_DIR}/${2}.json"
}

function expand_inheritances() {
  local _filename="${1}"
  local _validation_mode="${2}"
  local _jf_path="${3}"
  local _caching_filename
  _caching_filename="${_JF_POOL_DIR}/$(hashcode "${_filename}")"
  perf "begin: ${_filename}(cache:'${_caching_filename}' in ${_JF_POOL_DIR}; )"
  [[ -e "${_caching_filename}" ]] || {
    perf "expanding inheritances for file: '${_filename}'"
    _expand_inheritances "${_filename}" "${_validation_mode}" "${_jf_path}" >"${_caching_filename}"
  }
  cat "${_caching_filename}"
  perf "end: ${_filename} (cached in ${_caching_filename})"
}

function _expand_inheritances() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _jf_path="${3}"
  local _content _out
  perf "begin: ${_target}"
  _target="$(find_file_in_path "${_target}" "${_jf_path}")"
  # Fail on command substitution cannot be checked directly
  # shellcheck disable=SC2181
  [[ $? == 0 ]] || abort "Failed to find a file '${_target}'."
  _jf_path="$(dirof "${_target}"):${_jf_path}"
  _content="$(cat "${_target}")"
  debug "check - 1"
  if ! is_json "${_content}"; then
    abort "Malformed JSON was given:'${_target}'='${_content}'"
  fi
  debug "check - 2"
  if is_object "${_content}"; then
    local _tmp _private_nodes_dir _c _expanded
    debug "check - 3a"
    ####
    # Strangely the line above does not causes a quit on a failure.
    # Explitly check and abotrt this functino.
    _c="$(expand_filelevel_inheritances "${_target}" "${_validation_mode}" "${_jf_path}")" ||
      abort "File-level expansion failed for '${_target}'"
    debug "check - 3b"
    _tmp="$(mktemp_with_content "${_c}")"
    _private_nodes_dir=$(materialize_private_nodes "${_tmp}")
    debug "check - 3c"
    expand_inheritances_of_private_nodes "${_private_nodes_dir}" \
      "${_templating}" \
      "${_private_nodes_dir}:${_jf_path}"
    _expanded="$(expand_nodelevel_inheritances "${_tmp}" "${_validation_mode}" "${_private_nodes_dir}:${_jf_path}")" || abort "Failed to expand node level inheritance for file:'${_target}'(3)"
    _out=$(mktemp_with_content "${_expanded}")
    debug "check - 3d"
  else
    : # Clear $?
    debug "check - 4a"
    _out="$(mktemp_with_content "${_content}")"
    debug "check - 4b"
  fi
  debug "check - 5a"
  cat "${_out}"
  debug "check - 6a"
  perf "end: ${_target}"
}

function perform_templating() {
  perf "begin"
  local _src_file="${1}"
  local _content _ret
  # define builtin functions such as "ref", "self"
  _define_builtin_functions
  # source files, for which SOURCE directive is specified
  _source_files
  _perform_templating "$(cat "${_src_file}")"
  perf "end"
}

function perform_jqfront() {
  local _target="${1}"
  local _templating="${2}"
  local _validation_mode="${3}"
  local _jf_path="${4}"
  local _content
  perf "begin"
  mkdir -p "$(_sourced_files_dir)"
  _content="$(expand_inheritances "${_target}" "${_validation_mode}" "${_jf_path}")"
  _content=$(echo "${_content}" | jq '.|del(."$local")')
  if [[ "${_templating}" == "yes" ]]; then
    local _out
    _out=$(mktemp_with_content "${_content}")
    _content=$(perform_templating "${_out}")
  fi
  echo "${_content}"
  perf "end"
}

function usage() {
  message "Usage: $0 [-h|--help] [-e|--enable-templating] [-e|--enable-templating] [--validation=[no|lenient|strict]] TARGET"
}

function main() {
  # Call getopt to validate the provided input.
  options=$(getopt -o hde --long help,disable-templating,enable-templating,validation: -- "$@") || {
    usage_exit
  }
  if [[ $# -gt 0 ]]; then
    eval set -- "$options"
    while true; do
      case "${1}" in
      -h | --help)
        usage
        exit 0
        ;;
      -d | --disable-templating)
        _JF_TEMPLATING_ENABLED=no
        shift
        ;;
      -e | --enable-templating)
        _JF_TEMPLATING_ENABLED=yes
        shift
        ;;
      --validation)
        _JF_VALIDATION=$2
        shift
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        abort "Internal error!"
        ;;
      esac
    done
  fi
  if [[ $# == 0 ]]; then
    _target="$(mktemp_with_content "$(cat)")"
  else
    _target="${1}"
  fi
  mkdir -p "${_JF_SESSION_DIR}"
  perform_jqfront "${_target}" "${_JF_TEMPLATING_ENABLED}" "${_JF_VALIDATION}" "${_JF_PATH}"
}

_JF_CWD="${JF_CWD:-"$(pwd)"}"
_JF_BASEDIR="${JF_BASEDIR}"
_JF_SCHEMA_DIR="${_JF_BASEDIR}/schema"
_JF_PATH_BASE=${JF_PATH_BASE:-""}
_JF_PATH=$(_mangle_path "${JF_PATH:-"."}" "${_JF_PATH_BASE}")
_JF_TEMPLATING_ENABLED=${JF_TEMPLATING_ENABLED:-"yes"}
_JF_VALIDATION=${JF_VALIDATION:-"no"}
_JF_DEBUG=${JF_DEBUG:-"disabled"}
_JF_PERF=${JF_PERF:-"${_JF_DEBUG}"}
_JF_SESSION_ID="$(date +%s.%N)"
_JF_SESSION_DIR="/tmp/jq-front-${_JF_SESSION_ID}"

debug "_JF_CWD=${_JF_CWD}"
debug "_JF_BASEDIR=${_JF_BASEDIR}"
####
# JF_PATH_BASE is set when this program is run under Docker.
debug "_JF_PATH_BASE=${_JF_PATH_BASE}"
debug "_JF_PATH=${_JF_PATH}"
debug "_JF_TEMPLATING_ENABLED=${_JF_TEMPLATING_ENABLED}"
debug "_JF_VALIDATION=${_JF_VALIDATION}"
debug "_JF_DEBUG=${_JF_DEBUG}"
debug "_JF_PERF=${_JF_PERF}"

if [[ ${_JF_DEBUG} == enabled ]]; then
  trap _debug_abort ERR
fi

####
# Export JF_PATH_BASE, which is set for executions under Docker
if [[ -n "${_JF_PATH_BASE}" ]]; then
  export TMPDIR="${_JF_PATH_BASE}/tmp"
fi
export_names_for_script_inheritance
export _JF_POOL_DIR
_JF_POOL_DIR="$(nodepool_prepare _nodepool_expand_inheritances)"

main "${@}"
