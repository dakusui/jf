#!/usr/bin/env bash
set -E -eu -o pipefail
shopt -s inherit_errexit

JF_BASEDIR=$(dirname "$(readlink --canonicalize "${0}")")
export JF_BASEDIR

# shellcheck disable=SC1090
# source = lib/shared.sh
source "${JF_BASEDIR}/lib/shared.sh"
# shellcheck disable=SC1090
# source = lib/templating.sh
source "${JF_BASEDIR}/lib/templating.sh"

function _debug_abort() {
  print_stacktrace "DEBUG: error trapped"
  exit 1
}

function _mangle_path() {
  local _path="${1}"
  local _path_base="${2}"
  local _ret=""
  if [[ -z "${_path_base}" ]]; then
    echo "${_path}"
    return 0
  fi
  IFS=":" read -r -a _arr <<<"${_path}"
  for i in "${_arr[@]}"; do
    local _cur="${_path_base}"
    if [[ ${i} == .* ]]; then
      # _JF_CWD always starts with '/' since it is an absolute path to current working directory by definition.
      _cur="${_cur}${i/./${_JF_CWD}}"
    else
      _cur="${_cur}${i}"
    fi
    if [[ "${_ret}" == "" ]]; then
      _ret="${_cur}"
    else
      _ret="${_ret}:${_cur}"
    fi
  done
  echo "${_path_base}:${_ret}"
}

function _remove_meta_nodes() {
  local _content="${1}"
  local _cur
  if is_object "${_content}"; then
    local _keys
    local i
    _cur="$(mktemp_with_content "${_content}")"
    # Intentional single quote to find a keyword that starts with '$'
    # shellcheck disable=SC2016
    mapfile -t _keys < <(all_paths "${_content}" | grep '"$extends"$') || _keys=()
    for i in "${_keys[@]}"; do
      local _next
      _next="$(mktemp_with_content "$(jq ".|del(${i})" "${_cur}")")"
      _cur="${_next}"
    done
    cat "${_cur}"
  else
    echo "${_content}"
  fi
}

# Latter overrides former
function _merge_object_nodes() {
  local _a="${1}"
  local _b="${2}"
  local _error
  _error=$(mktemp)
  jq -r -c -n '$a * $b' --argjson a "${_a}" --argjson b "${_b}" || {
    abort "Failed to merge object nodes:'${_a}' and '${_b}': error: ${_error}"
  }
}

# Latter overrides former
function _merge_object_node_files() {
  local _a="${1}"
  local _b="${2}"
  local _error
  _error=$(mktemp)
  jq -s '.[0] * .[1]' "${_a}" "${_b}" 2>"${_error}" || {
    abort "Failed to merge object node files:'${_a}' and '${_b}': error: ${_error}"
  }
}

function _expand_nodelevel_inheritances() {
  local _content="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _cur
  local _in
  local -a _keys
  _cur=$(mktemp_with_content '{}')
  # Intentional single quote to find a keyword that starts with '$'
  # shellcheck disable=SC2016
  mapfile -t _keys < <(all_paths "${_content}" | grep '"$extends"$') || _keys=()
  for i in "${_keys[@]}"; do
    local -a _extendeds
    local _p="${i%.\"\$extends\"}"
    mapfile -t _extendeds < <(echo "${_content}" | jq -r -c "${i}[]") || _extendeds=()
    for j in "${_extendeds[@]}"; do
      local _jj
      local _merged_piece
      local _cur_content
      local _tmp_content
      if ! _jj="$(locate_file_in_path "${j}" "${_validation_mode}" "${_path}")"; then
        abort "Failed to locate file '${j}'"
      fi
      local _next_content
      _next_content="$(cat "${_jj}")"
      is_json "${_next_content}" || abort "Malformed JSON was given:'${_jj}'='${_next_content}'"
      _cur_content="$(cat "${_cur}")"
      if has_value_at "${_p}" "${_cur_content}"; then
        local _cur_piece
        _cur_piece="$(echo "${_cur_content}" | jq "${_p}")"
        _merged_piece=$(mktemp_with_content "$(_merge_object_nodes "${_cur_piece}" "$(cat "${_jj}")")")
      else
        _merged_piece="${_jj}"
      fi
      _tmp_content="$(jq -n "input | ${_p}=input" "${_cur}" "${_merged_piece}")"
      _cur=$(mktemp_with_content "${_tmp_content}")
    done
  done
  jq -r -c . "${_cur}"
}

function locate_file_in_path() {
  local _in="${1}"
  local _mode="${2}"
  local _path="${3}"
  local _ret
  if ! _ret="$(find_file_in_path "${j}" "${_path}")"; then
    abort "Failed to find file '${_in}'"
  fi
  debug "validating ${_in}"
  validate_jf_json "${_in}" "${_validation_mode}"
  debug "...validated"
  echo "${_ret}"
}

function _validate_jf_json_with() {
  local _in="${1}"
  local _mode="${2}"
  local _out=
  {
    _out=$(ajv validate -s "${_JF_SCHEMA_DIR}/${_mode}.json" -d "${_in}" 2>&1)
  } || {
    abort "Validation by ajv for '${_in}' was failed:\n${_out}"
  }
}

function _render_text_node() {
  local _node_value="${1}"
  local _path="${2}"
  local _mode="raw"
  local _quote="yes"
  local _body
  local _ret
  debug "rendering"
  if [[ "${_node_value}" == template:* || "${_node_value}" == raw:* ]]; then
    _mode="${_node_value%%:*}"
    _body="${_node_value#*:}"
    if [[ "${_body}" == object:* || "${_body}" == array:* || "${_body}" == string:* || "${_body}" == number:* || "${_body}" == boolean:* ]] \
      ; then
      if [[ "${_body}" != string:* ]]; then
        _quote="no"
      fi
      _body="${_body#*:}"
    fi
  else
    _body="${_node_value}"
  fi

  if [[ "${_mode}" == "template" ]]; then
    _ret=$(eval echo "${_body}")
  elif [[ "${_mode}" == "raw" ]]; then
    _ret="${_body}"
  fi
  debug "rendered:_mode='${_mode}'"
  if [[ "${_quote}" == yes ]]; then
    _ret="${_ret//\\/\\\\}"
    echo "\"${_ret//\"/\\\"}\""
  else
    echo "${_ret}"
  fi
}

#" double quotetion is placed here to resest broken syntax hilighting of IntelliJ 'shell-support' plugin

function _type_of() {
  local _path="${1}"
  local _content="${2}"
  echo "${_content}" | jq -r -c "${_path}|type"
}

function _paths_type_of() {
  local _type="${1}"
  local _content="${2}"
  local i
  local -a _paths
  debug "scanning _type=${_type},_content=${_content}"
  mapfile -t _paths < <(all_paths "${_content}")
  for i in "${_paths[@]}"; do
    local _t
    _t="$(_type_of "${i}" "${_content}")"
    if [[ "${_t}" == "${_type}" ]]; then
      debug "    read:'${i}'"
      echo "${i}"
    fi
  done
  debug "scanned"
}

function _perform_templating() {
  local _content="${1}"
  local _ret="${_content}"
  local i
  local -a _keys
  debug "templating"
  mapfile -t _keys < <(_paths_type_of "string" "${_content}")
  debug "splitted"
  for i in "${_keys[@]}"; do
    local _node_value
    local _templated_node_value
    debug "processing:${i}"
    _node_value="$(value_at "${i}" "${_content}")"
    _templated_node_value="$(_render_text_node "${_node_value}" "${i}")"
    debug "node:'${_ret}':'${i}':'${_templated_node_value}'"
    _ret="$(jq -r -c -n "input|${i}=input" <(echo "${_ret}") <(echo "${_templated_node_value}"))"
    debug "processed:${i}"
  done
  debug "templated:'${_ret}'"
  echo "${_ret}"
}

function find_file_in_path() {
  local _target="${1}"
  local _path="${2}"
  IFS=';' read -r -a _arr <<<"${_target}"
  if [[ ${#_arr[@]} -le 1 ]]; then
    search_file_in "${1}" "${2}"
  elif [[ ${#_arr[@]} -gt 1 ]]; then
    ####
    # In case the file name contains one or more semi-colons(';'), the name will be splitted by it.
    # And a command line is constructed from them and executed.
    local _f
    _f="$(search_file_in "${_arr[0]}" "${_path}")" || abort "Script file ${_arr[1]} was not found in '${_path}'"
    export _path
    mktemp_with_content "$(${_arr[1]} "${_f}" "${_arr[@]:2}")"
    unset _path
  fi
}

####
#
# Function intended to be used on 'script inheritance'.
# Search for a file from an environment variable "_JF_PATH" and prints an absolute path of it if found.
# In case it is not found, 1 will be returned.
#
# This function is indirectly called by 'find_file_in_path' through a command line it constructs
#
function find_file() {
  local _target="${1}"
  search_file_in "${_target}" "${_path}"
}

function export_names_for_script_inheritance() {
  export -f find_file
  export -f search_file_in
  export -f abort
  export -f message
  export _JF_PATH
  export _JF_PATH_BASE
}

function validate_jf_json() {
  local _in="${1}"
  local _mode="${2}"
  if [[ "${_mode}" == "no" ]]; then
    return 0
  elif [[ "${_mode}" == "strict" ]]; then
    _validate_jf_json_with "${_in}" "strict"
  elif [[ "${_mode}" == "lenient" ]]; then
    _validate_jf_json_with "${_in}" "lenient"
  else
    abort "Unknown validation mode:'${_mode}' was set."
  fi
  return $?
}

function dirof() {
  local _target="${1}"
  local _ret
  _ret=$(dirname "$(readlink --canonicalize-missing "${_target}")")
  echo "${_ret}"
}

function expand_filelevel_inheritances() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _in
  debug "begin:expand_filelevel_inheritances:_target=${_target}"
  ####
  # This is intentionally using single quotes to pass quoted path expression to jq.
  # shellcheck disable=SC2016
  local _cur
  local _content
  _in="$(find_file_in_path "${_target}" "${_path}")"
  debug "validating ${_in}"
  validate_jf_json "${_in}" "${_validation_mode}"
  debug "...validated"
  _content="$(cat "${_in}")"
  _cur="$(mktemp_with_content "${_content}")"
  if is_object "${_content}"; then
    # shellcheck disable=SC2016
    # this is intentionally suppressing expansion to pass the value to jq.
    if has_value_at '."$extends"' "${_content}"; then
      local i
      while IFS= read -r i; do
        local _next
        local _c
        local _parent
        _parent="$(run_jqfront "${i}" "${_validation_mode}" "${_path}")"
        _c="$(_merge_object_nodes "${_parent}" "$(cat "${_cur}")")"
        _next=$(mktemp_with_content "${_c}")
        _cur="${_next}"
      done <<<"$(value_at '."$extends"[]' "${_content}")"
    fi
    jq -r -c '.|del(.["$extends"])' "$(find_file_in_path "${_cur}" "${_path}")"
  else
    cat "$(find_file_in_path "${_cur}" "${_path}")"
  fi
  debug "end:expand_filelevel_inheritances"
}

function materialize_private_nodes() {
  local _target="${1}"
  local _content
  local _ret
  debug "begin:materialize_private_nodes"
  _content="$(cat "${_target}")"
  _ret="$(mktemp -d)"
  # Intentional single quotes for jq.
  # shellcheck disable=SC2016
  if has_value_at '."$local"' "${_content}"; then
    # shellcheck disable=SC2016
    for i in $(keys_of '."$local"' "${_content}"); do
      echo "${_content}" | jq '."$local".''"'"${i}"'"' >"${_ret}/${i}"
    done
  fi
  echo "${_ret}"
  debug "end:materialize_private_nodes"
}

function expand_nodelevel_inheritances() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _path="${3}"
  local _expanded
  local _expanded_clean
  local _clean
  local _content
  debug "begin:expand_nodelevel_inheritances:_target=${_target}"
  _content="$(cat "${_target}")"
  _expanded="$(_expand_nodelevel_inheritances "${_content}" "${_validation_mode}" "${_path}")"
  _clean="$(_remove_meta_nodes "${_content}")"
  _expanded_clean="$(_remove_meta_nodes "${_expanded}")"
  _merge_object_nodes "${_expanded_clean}" "${_clean}"
  debug "end:expand_nodelevel_inheritances"
}

function expand_inheritances_of_private_nodes() {
  local _path="${1}"
  local _templating="${2}"
  local _jf_path="${3}"
  debug "begin: expand_inheritances_of_private_nodes in ${_path}"
  while IFS= read -r -d '' i; do
    local _tmp
    local _f="${i}"
    debug "expanding inheritance of private node:${i}"
    _tmp="$(mktemp_with_content "$(run_jqfront "${_f}" "no" "${_path}:${_jf_path}")")"
    cp "${_tmp}" "${_f}"
    debug "...expanded"
  done < <(find "${_path}" -maxdepth 1 -type f -print0)
  debug "end:   expand_inheritances_of_private_nodes"
}

function perform_templating() {
  debug "begin:perform_templating"
  local _src_file="${1}"
  local _content
  local _ret
  _perform_templating "$(cat "${_src_file}")"
  debug "end:perform_templating"
}

function run_jqfront() {
  local _target="${1}"
  local _validation_mode="${2}"
  local _jf_path="${3}"
  local _content
  local _out
  debug "begin:run_jqfront:_target=${_target}"
  _target="$(find_file_in_path "${_target}" "${_jf_path}")"
  [[ $? == 0 ]] || abort "Failed to find a file '${_target}'."
  _jf_path="$(dirof "${_target}"):${_jf_path}"
  _content="$(cat "${_target}")"
  if ! is_json "${_content}"; then
    abort "Malformed JSON was given:'${_target}'='${_content}'"
  fi
  if is_object "${_content}"; then
    local _tmp
    local _private_nodes_dir
    local _c
    ####
    # Strangely the line above does not causes a quit on a failure.
    # Explitly check and abotrt this functino.
    if ! _c="$(expand_filelevel_inheritances "${_target}" "${_validation_mode}" "${_jf_path}")"; then
      abort "File-level expansion failed for '${_target}'"
    fi
    _tmp="$(mktemp_with_content "${_c}")"
    _private_nodes_dir=$(materialize_private_nodes "${_tmp}")
    expand_inheritances_of_private_nodes "${_private_nodes_dir}" \
      "${_templating}" \
      "${_private_nodes_dir}:${_jf_path}"
    _out=$(mktemp_with_content "$(expand_nodelevel_inheritances "${_tmp}" "${_validation_mode}" "${_private_nodes_dir}:${_jf_path}")")
  else
    debug "non object file:${_target}"
    _out="$(mktemp_with_content "${_content}")"
  fi
  cat "${_out}"
  debug "end:run_jqfront"
}

function perform_jqfront() {
  local _target="${1}"
  local _templating="${2}"
  local _validation_mode="${3}"
  local _jf_path="${4}"
  local _content
  _content="$(run_jqfront "${_target}" "${_validation_mode}" "${_jf_path}")"
  _content=$(echo "${_content}" | jq '.|del(."$local")')
  if [[ "${_templating}" == "yes" ]]; then
    local _out
    _out=$(mktemp_with_content "${_content}")
    _content=$(perform_templating "${_out}")
  fi
  echo "${_content}"
}

function usage_exit() {
  abort "Usage: $0 [-h|--help] [-e|--enable-templating] [-e|--enable-templating] [--validation=[no|lenient|strict]] TARGET"
}

function main() {
  # Call getopt to validate the provided input.
  options=$(getopt -o hde --long help,disable-templating,enable-templating,validation: -- "$@") || {
    usage_exit
  }
  if [[ $# -gt 0 ]]; then
    eval set -- "$options"
    while true; do
      case "${1}" in
      -h | --help)
        usage_exit
        ;;
      -d | --disable-templating)
        _JF_TEMPLATING_ENABLED=no
        shift
        ;;
      -e | --enable-templating)
        _JF_TEMPLATING_ENABLED=yes
        shift
        ;;
      --validation)
        _JF_VALIDATION=$2
        shift
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        abort "Internal error!"
        ;;
      esac
    done
  fi
  if [[ $# == 0 ]]; then
    _target="$(mktemp_with_content "$(cat)")"
  else
    _target="${1}"
  fi
  perform_jqfront "${_target}" "${_JF_TEMPLATING_ENABLED}" "${_JF_VALIDATION}" "${_JF_PATH}"
}

_JF_CWD="${JF_CWD:-"$(pwd)"}"
_JF_BASEDIR="${JF_BASEDIR}"
_JF_SCHEMA_DIR="${_JF_BASEDIR}/schema"
_JF_PATH_BASE=${JF_PATH_BASE:-""}
_JF_PATH=$(_mangle_path "${JF_PATH:-"."}" "${_JF_PATH_BASE}")
_JF_TEMPLATING_ENABLED=${JF_TEMPLATING_ENABLED:-"yes"}
_JF_VALIDATION=${JF_VALIDATION:-"no"}
_JF_DEBUG=${JF_DEBUG:-"disabled"}

debug "_JF_CWD=${_JF_CWD}"
debug "_JF_BASEDIR=${_JF_BASEDIR}"
####
# JF_PATH_BASE is set when this program is run under Docker.
debug "_JF_PATH_BASE=${_JF_PATH_BASE}"
debug "_JF_PATH=${_JF_PATH}"
debug "_JF_TEMPLATING_ENABLED=${_JF_TEMPLATING_ENABLED}"
debug "_JF_VALIDATION=${_JF_VALIDATION}"
debug "_JF_DEBUG=${_JF_DEBUG}"

if [[ ${_JF_DEBUG} == enabled ]]; then
  trap _debug_abort ERR
fi

####
# Export JF_PATH_BASE, which is set for executions under Docker
if [[ -n "${_JF_PATH_BASE}" ]]; then
  export TMPDIR="${_JF_PATH_BASE}/tmp"
fi
export_names_for_script_inheritance

main "${@}"
